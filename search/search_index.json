{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the BAG Wiki! This is a wiki for Leeds Biosphere and Atmosphere Group (BAG) to share computing and technical guides and tips Contributing If you'd like to contribute, thank you! There a few ways to do this: - With a GitHub account invited to this Organisation, you can add files (tutorials etc) and publish website changes - To add files to the website, go to the docs folder and create or upload a file - Commit this change using the button, writing a short description of your change - Link your file on the website, by editing 'mkdocs.yml' and listing your file information in the how to guides section - Without permissions, you can submit text files, word docs, markdown files to admin and they can be uploaded on your behalf","title":"Home"},{"location":"#welcome-to-the-bag-wiki","text":"This is a wiki for Leeds Biosphere and Atmosphere Group (BAG) to share computing and technical guides and tips","title":"Welcome to the BAG Wiki!"},{"location":"#contributing","text":"If you'd like to contribute, thank you! There a few ways to do this: - With a GitHub account invited to this Organisation, you can add files (tutorials etc) and publish website changes - To add files to the website, go to the docs folder and create or upload a file - Commit this change using the button, writing a short description of your change - Link your file on the website, by editing 'mkdocs.yml' and listing your file information in the how to guides section - Without permissions, you can submit text files, word docs, markdown files to admin and they can be uploaded on your behalf","title":"Contributing"},{"location":"conda_setup/","text":"Guide to Setting Up Mamba (Conda) on a Linux Machine Author: Callum What is Mamba? Mamba is a fast, robust, and user-friendly package manager for managing environments and packages in the Conda ecosystem. It is a drop-in replacement for the Conda command-line tool, written in C++ for speed and efficiency. Mamba uses the same environment and package specifications as Conda, but resolves dependencies and installs packages much faster, making it ideal for scientific computing, data science, and reproducible research. Why Use Mamba? Speed : Mamba is significantly faster than Conda, especially for solving complex dependencies and installing large packages. Reliability : Mamba uses parallel downloading and a more efficient dependency resolver, reducing installation errors and timeouts. Compatibility : Mamba works seamlessly with existing Conda environments and packages. You can use mamba and conda commands interchangeably. Community Support : Mamba is developed and maintained by the open-source community, with strong support from the conda-forge project. Installing Mamba via Miniforge Miniforge is a minimal installer for Conda and Mamba, maintained by conda-forge. It is recommended for Unix-like platforms (Linux, macOS, WSL) and comes with Mamba pre-installed. Step 1: Download the Miniforge Installer Open a terminal and download the installer appropriate for your system architecture. You can use wget : Using wget: wget \"https://github.com/conda-forge/miniforge/releases/latest/download/Miniforge3-$(uname)-$(uname -m).sh\" Step 2: Run the Installer Script Run the downloaded script to install Miniforge (and Mamba): bash Miniforge3-$(uname)-$(uname -m).sh Follow the prompts to complete the installation. By default, Miniforge will install to your home directory (e.g., ~/miniforge3 ). Step 3: Initialize Conda After installation, initialize Conda in your shell: source ~/miniforge3/bin/activate conda init Restart your terminal to activate Conda automatically. Using Mamba Mamba is a drop-in replacement for Conda. Simply use mamba instead of conda for faster operations: Create a new environment: bash mamba create -n myenv python=3.11 numpy pandas Activate an environment: bash conda activate myenv Install packages: bash mamba install scipy matplotlib Update packages: bash mamba update --all List environments: bash mamba env list Remove an environment: bash mamba env remove -n myenv Tips and Best Practices Always use the conda-forge channel for the latest, community-maintained packages. Why Use conda-forge? Using the conda-forge channel is important because it ensures all packages in your environment are built and maintained by the same community, following consistent standards. This greatly reduces the risk of dependency conflicts and broken environments that can occur when mixing packages from different channels. Conda-forge provides up-to-date versions, broad compatibility, and reliable builds for scientific and data science packages. By sticking to conda-forge, you make your environment more reproducible and robust. To update Mamba itself: bash mamba update mamba For troubleshooting, use verbose mode: bash mamba install <package> --verbose Further Reading Mamba Documentation Miniforge GitHub Conda-forge Mamba makes managing scientific Python environments fast, reliable, and reproducible. Enjoy your new setup! Installing mamba This works best in a clean environment. Create a new conda environment and install mamba using conda conda install -c conda-forge mamba","title":"Mamba Set Up"},{"location":"conda_setup/#guide-to-setting-up-mamba-conda-on-a-linux-machine","text":"Author: Callum","title":"Guide to Setting Up Mamba (Conda) on a Linux Machine"},{"location":"conda_setup/#what-is-mamba","text":"Mamba is a fast, robust, and user-friendly package manager for managing environments and packages in the Conda ecosystem. It is a drop-in replacement for the Conda command-line tool, written in C++ for speed and efficiency. Mamba uses the same environment and package specifications as Conda, but resolves dependencies and installs packages much faster, making it ideal for scientific computing, data science, and reproducible research.","title":"What is Mamba?"},{"location":"conda_setup/#why-use-mamba","text":"Speed : Mamba is significantly faster than Conda, especially for solving complex dependencies and installing large packages. Reliability : Mamba uses parallel downloading and a more efficient dependency resolver, reducing installation errors and timeouts. Compatibility : Mamba works seamlessly with existing Conda environments and packages. You can use mamba and conda commands interchangeably. Community Support : Mamba is developed and maintained by the open-source community, with strong support from the conda-forge project.","title":"Why Use Mamba?"},{"location":"conda_setup/#installing-mamba-via-miniforge","text":"Miniforge is a minimal installer for Conda and Mamba, maintained by conda-forge. It is recommended for Unix-like platforms (Linux, macOS, WSL) and comes with Mamba pre-installed.","title":"Installing Mamba via Miniforge"},{"location":"conda_setup/#step-1-download-the-miniforge-installer","text":"Open a terminal and download the installer appropriate for your system architecture. You can use wget : Using wget: wget \"https://github.com/conda-forge/miniforge/releases/latest/download/Miniforge3-$(uname)-$(uname -m).sh\"","title":"Step 1: Download the Miniforge Installer"},{"location":"conda_setup/#step-2-run-the-installer-script","text":"Run the downloaded script to install Miniforge (and Mamba): bash Miniforge3-$(uname)-$(uname -m).sh Follow the prompts to complete the installation. By default, Miniforge will install to your home directory (e.g., ~/miniforge3 ).","title":"Step 2: Run the Installer Script"},{"location":"conda_setup/#step-3-initialize-conda","text":"After installation, initialize Conda in your shell: source ~/miniforge3/bin/activate conda init Restart your terminal to activate Conda automatically.","title":"Step 3: Initialize Conda"},{"location":"conda_setup/#using-mamba","text":"Mamba is a drop-in replacement for Conda. Simply use mamba instead of conda for faster operations: Create a new environment: bash mamba create -n myenv python=3.11 numpy pandas Activate an environment: bash conda activate myenv Install packages: bash mamba install scipy matplotlib Update packages: bash mamba update --all List environments: bash mamba env list Remove an environment: bash mamba env remove -n myenv","title":"Using Mamba"},{"location":"conda_setup/#tips-and-best-practices","text":"Always use the conda-forge channel for the latest, community-maintained packages.","title":"Tips and Best Practices"},{"location":"conda_setup/#why-use-conda-forge","text":"Using the conda-forge channel is important because it ensures all packages in your environment are built and maintained by the same community, following consistent standards. This greatly reduces the risk of dependency conflicts and broken environments that can occur when mixing packages from different channels. Conda-forge provides up-to-date versions, broad compatibility, and reliable builds for scientific and data science packages. By sticking to conda-forge, you make your environment more reproducible and robust. To update Mamba itself: bash mamba update mamba For troubleshooting, use verbose mode: bash mamba install <package> --verbose","title":"Why Use conda-forge?"},{"location":"conda_setup/#further-reading","text":"Mamba Documentation Miniforge GitHub Conda-forge Mamba makes managing scientific Python environments fast, reliable, and reproducible. Enjoy your new setup!","title":"Further Reading"},{"location":"conda_setup/#installing-mamba","text":"This works best in a clean environment. Create a new conda environment and install mamba using conda conda install -c conda-forge mamba","title":"Installing mamba"},{"location":"how_to_regrid_xesmf_tutorial/","text":"Tutorial: Regridding 2D NetCDF Datasets in Python with xESMF Author: Callum Regridding (also called remapping or resampling) is a common task in geosciences, especially when working with gridded data such as satellite or climate model outputs. The goal is to interpolate data from one grid to another, which is essential for comparing datasets, combining products, or preparing data for models. In this tutorial, we'll use the Python package xESMF to regrid 2D NetCDF datasets. xESMF is built on top of xarray and ESMF, providing a simple interface for regridding with various algorithms. Prerequisites Install the required packages: mamba install xarray xesmf 1. Loading a NetCDF Dataset We'll use xarray to open NetCDF files. Here, we assume you have a 2D variable (e.g., satellite data) with latitude and longitude coordinates. import xarray as xr ds = xr.open_dataset('input_data.nc') print(ds) Plotting the Input Data import matplotlib.pyplot as plt ds['your_variable'].plot() plt.title('Original Data on Source Grid') plt.show() 2. Defining the Target Grid You need to define the grid you want to regrid to. This can be another dataset's grid, or you can create a new one. Here, we create a regular lat/lon grid: import numpy as np target_grid = xr.Dataset({ 'lat': (['lat'], np.arange(-90, 90.1, 1.0)), 'lon': (['lon'], np.arange(0, 360, 1.0)), }) Visualizing the Target Grid plt.figure() plt.scatter(target_grid['lon'], target_grid['lat'], s=1) plt.xlabel('Longitude') plt.ylabel('Latitude') plt.title('Target Grid Points') plt.show() 3. Regridding with xESMF xESMF supports several regridding methods: Choosing a Regridding Algorithm The choice of algorithm depends on your data and scientific goals: Bilinear : Uses weighted averages of the four nearest grid points. It is smooth and works well for continuous variables (e.g., temperature, pressure). However, it does not conserve the total sum of the variable, so it is not suitable for fluxes or quantities where conservation is important. Conservative : Ensures that the integral (sum) of the variable is preserved during regridding. This is essential for variables like precipitation, runoff, or any fluxes. It requires both source and target grids to define cell boundaries (i.e., grid must be defined by cell centers and edges). It can be sensitive to missing values (NaNs), which may cause the output to be NaN if any input cell is NaN. Conservative-normed : Similar to conservative, but normalizes the weights so that if some source cells are NaN, the valid part of the cell is still used. This is especially useful for satellite data or observational products with missing values, as it avoids propagating NaNs unnecessarily. Use this when you want conservation but need to handle missing data robustly. Nearest_s2d / nearest_d2s : Assigns the value of the nearest source (or destination) grid cell. This is fast and preserves original values, but can introduce blocky artifacts. Use for categorical data (e.g., land/sea masks, land cover types) or when you want to avoid interpolation. Patch : A higher-order method that can provide smoother results for some variables, but is less commonly used and more computationally intensive. Summary Table Algorithm Preserves Integrals Handles NaNs Well Smooth Use For bilinear No Moderate Yes Continuous fields conservative Yes No No Fluxes, precipitation conservative-normed Yes Yes No Fluxes with missing data nearest_s2d/d2s No Yes No Categorical, masks patch No Moderate Yes Advanced, smooth fields Example: Bilinear Regridding import xesmf as xe regridder = xe.Regridder(ds, target_grid, 'bilinear') regridded = regridder(ds['your_variable']) regridded.to_netcdf('output_bilinear.nc') Example: Conservative Regridding regridder_cons = xe.Regridder(ds, target_grid, 'conservative') regridded_cons = regridder_cons(ds['your_variable']) regridded_cons.to_netcdf('output_conservative.nc') Example: Conservative-normed Regridding The conservative-normed method is designed to handle missing values (NaNs) more robustly than standard conservative regridding. In the standard conservative method, if any part of a source cell is NaN, the entire destination cell may become NaN. The conservative-normed method normalizes the weights so that only the valid (non-NaN) fraction of the source cell contributes to the destination cell, preventing unnecessary propagation of NaNs. Using a 'mask' Layer To take full advantage of conservative-normed, you should provide a mask variable in your xarray dataset. This mask should be a DataArray with the same shape as your data, where valid data points are marked as 1 (or True) and missing/invalid points as 0 (or False). xESMF will use this mask to determine which parts of the grid are valid during regridding. Example of adding a mask: import numpy as np # Suppose ds['your_variable'] contains NaNs for missing data mask = (~np.isnan(ds['your_variable'])).astype(int) ds['mask'] = (ds['your_variable'].dims, mask) # Now use conservative-normed regridder_normed = xe.Regridder(ds, target_grid, 'conservative_normed') regridded_normed = regridder_normed(ds['your_variable']) regridded_normed.to_netcdf('output_conservative_normed.nc') If you do not provide a mask, xESMF will infer it from the NaN pattern in your data, but explicitly providing a mask is more robust and recommended for complex or irregular missing data patterns. For more, see the xESMF documentation on masking . Example: Nearest Neighbor Regridding regridder_nn = xe.Regridder(ds, target_grid, 'nearest_s2d') regridded_nn = regridder_nn(ds['your_variable']) regridded_nn.to_netcdf('output_nearest.nc') 4. Considerations Working with Large Datasets Regridding large datasets (e.g., high-resolution satellite data or long time series) can be memory- and compute-intensive. Here are some tips to improve performance: Use Dask for Chunking : xarray and xESMF support dask arrays, which allow you to process data in chunks and parallelize operations. Open your dataset with chunking: ```python ds = xr.open_dataset('input_data.nc', chunks={'time': 10, 'lat': 100, 'lon': 100}) Adjust chunk sizes to fit your memory and data shape ``` Saving and Reusing Regridding Weights : When you create a regridder in xESMF, it computes a weight matrix that maps the source grid to the target grid. This computation can be slow for large grids, but you can save the weights to a file and reload them later for faster repeated regridding. Example: ```python First time: compute and save weights regridder = xe.Regridder(ds, target_grid, 'bilinear', filename='my_weights.nc') Next time: reuse the saved weights (much faster) regridder = xe.Regridder(ds, target_grid, 'bilinear', filename='my_weights.nc', reuse_weights=True) ``` This is especially useful when you need to regrid many variables or process data in chunks, as you only need to compute the weights once. Parallel Processing : If you have access to a cluster or multicore machine, dask can distribute the computation. Set up a dask cluster for even faster processing. Reduce Data Size : If possible, subset your data in time or space before regridding, or use coarser grids for exploratory analysis. Monitor Memory Usage : Large regridding operations can use a lot of RAM. Monitor your system and adjust chunk sizes or process data in smaller batches if needed. For more details, see the xESMF documentation on dask and performance . 5. Visualizing the Results import matplotlib.pyplot as plt regridded.plot() plt.title('Regridded Data (Bilinear)') plt.show() Comparing Input and Output You can compare the original and regridded data side by side: fig, axs = plt.subplots(1, 2, figsize=(12, 5)) ds['your_variable'].plot(ax=axs[0]) axs[0].set_title('Original Data') regridded.plot(ax=axs[1]) axs[1].set_title('Regridded Data (Bilinear)') plt.tight_layout() plt.show() For more advanced analysis, you can plot the difference: diff = regridded - ds['your_variable'].interp_like(regridded) diff.plot() plt.title('Difference After Regridding') plt.show() 6. References xESMF Documentation xarray Documentation This tutorial should help you get started with regridding 2D NetCDF datasets in Python using xESMF. Adjust the code to your specific data and needs!","title":"Regridding with Python"},{"location":"how_to_regrid_xesmf_tutorial/#tutorial-regridding-2d-netcdf-datasets-in-python-with-xesmf","text":"Author: Callum Regridding (also called remapping or resampling) is a common task in geosciences, especially when working with gridded data such as satellite or climate model outputs. The goal is to interpolate data from one grid to another, which is essential for comparing datasets, combining products, or preparing data for models. In this tutorial, we'll use the Python package xESMF to regrid 2D NetCDF datasets. xESMF is built on top of xarray and ESMF, providing a simple interface for regridding with various algorithms.","title":"Tutorial: Regridding 2D NetCDF Datasets in Python with xESMF"},{"location":"how_to_regrid_xesmf_tutorial/#prerequisites","text":"Install the required packages: mamba install xarray xesmf","title":"Prerequisites"},{"location":"how_to_regrid_xesmf_tutorial/#1-loading-a-netcdf-dataset","text":"We'll use xarray to open NetCDF files. Here, we assume you have a 2D variable (e.g., satellite data) with latitude and longitude coordinates. import xarray as xr ds = xr.open_dataset('input_data.nc') print(ds)","title":"1. Loading a NetCDF Dataset"},{"location":"how_to_regrid_xesmf_tutorial/#plotting-the-input-data","text":"import matplotlib.pyplot as plt ds['your_variable'].plot() plt.title('Original Data on Source Grid') plt.show()","title":"Plotting the Input Data"},{"location":"how_to_regrid_xesmf_tutorial/#2-defining-the-target-grid","text":"You need to define the grid you want to regrid to. This can be another dataset's grid, or you can create a new one. Here, we create a regular lat/lon grid: import numpy as np target_grid = xr.Dataset({ 'lat': (['lat'], np.arange(-90, 90.1, 1.0)), 'lon': (['lon'], np.arange(0, 360, 1.0)), })","title":"2. Defining the Target Grid"},{"location":"how_to_regrid_xesmf_tutorial/#visualizing-the-target-grid","text":"plt.figure() plt.scatter(target_grid['lon'], target_grid['lat'], s=1) plt.xlabel('Longitude') plt.ylabel('Latitude') plt.title('Target Grid Points') plt.show()","title":"Visualizing the Target Grid"},{"location":"how_to_regrid_xesmf_tutorial/#3-regridding-with-xesmf","text":"xESMF supports several regridding methods:","title":"3. Regridding with xESMF"},{"location":"how_to_regrid_xesmf_tutorial/#choosing-a-regridding-algorithm","text":"The choice of algorithm depends on your data and scientific goals: Bilinear : Uses weighted averages of the four nearest grid points. It is smooth and works well for continuous variables (e.g., temperature, pressure). However, it does not conserve the total sum of the variable, so it is not suitable for fluxes or quantities where conservation is important. Conservative : Ensures that the integral (sum) of the variable is preserved during regridding. This is essential for variables like precipitation, runoff, or any fluxes. It requires both source and target grids to define cell boundaries (i.e., grid must be defined by cell centers and edges). It can be sensitive to missing values (NaNs), which may cause the output to be NaN if any input cell is NaN. Conservative-normed : Similar to conservative, but normalizes the weights so that if some source cells are NaN, the valid part of the cell is still used. This is especially useful for satellite data or observational products with missing values, as it avoids propagating NaNs unnecessarily. Use this when you want conservation but need to handle missing data robustly. Nearest_s2d / nearest_d2s : Assigns the value of the nearest source (or destination) grid cell. This is fast and preserves original values, but can introduce blocky artifacts. Use for categorical data (e.g., land/sea masks, land cover types) or when you want to avoid interpolation. Patch : A higher-order method that can provide smoother results for some variables, but is less commonly used and more computationally intensive.","title":"Choosing a Regridding Algorithm"},{"location":"how_to_regrid_xesmf_tutorial/#summary-table","text":"Algorithm Preserves Integrals Handles NaNs Well Smooth Use For bilinear No Moderate Yes Continuous fields conservative Yes No No Fluxes, precipitation conservative-normed Yes Yes No Fluxes with missing data nearest_s2d/d2s No Yes No Categorical, masks patch No Moderate Yes Advanced, smooth fields","title":"Summary Table"},{"location":"how_to_regrid_xesmf_tutorial/#example-bilinear-regridding","text":"import xesmf as xe regridder = xe.Regridder(ds, target_grid, 'bilinear') regridded = regridder(ds['your_variable']) regridded.to_netcdf('output_bilinear.nc')","title":"Example: Bilinear Regridding"},{"location":"how_to_regrid_xesmf_tutorial/#example-conservative-regridding","text":"regridder_cons = xe.Regridder(ds, target_grid, 'conservative') regridded_cons = regridder_cons(ds['your_variable']) regridded_cons.to_netcdf('output_conservative.nc')","title":"Example: Conservative Regridding"},{"location":"how_to_regrid_xesmf_tutorial/#example-conservative-normed-regridding","text":"The conservative-normed method is designed to handle missing values (NaNs) more robustly than standard conservative regridding. In the standard conservative method, if any part of a source cell is NaN, the entire destination cell may become NaN. The conservative-normed method normalizes the weights so that only the valid (non-NaN) fraction of the source cell contributes to the destination cell, preventing unnecessary propagation of NaNs.","title":"Example: Conservative-normed Regridding"},{"location":"how_to_regrid_xesmf_tutorial/#using-a-mask-layer","text":"To take full advantage of conservative-normed, you should provide a mask variable in your xarray dataset. This mask should be a DataArray with the same shape as your data, where valid data points are marked as 1 (or True) and missing/invalid points as 0 (or False). xESMF will use this mask to determine which parts of the grid are valid during regridding. Example of adding a mask: import numpy as np # Suppose ds['your_variable'] contains NaNs for missing data mask = (~np.isnan(ds['your_variable'])).astype(int) ds['mask'] = (ds['your_variable'].dims, mask) # Now use conservative-normed regridder_normed = xe.Regridder(ds, target_grid, 'conservative_normed') regridded_normed = regridder_normed(ds['your_variable']) regridded_normed.to_netcdf('output_conservative_normed.nc') If you do not provide a mask, xESMF will infer it from the NaN pattern in your data, but explicitly providing a mask is more robust and recommended for complex or irregular missing data patterns. For more, see the xESMF documentation on masking .","title":"Using a 'mask' Layer"},{"location":"how_to_regrid_xesmf_tutorial/#example-nearest-neighbor-regridding","text":"regridder_nn = xe.Regridder(ds, target_grid, 'nearest_s2d') regridded_nn = regridder_nn(ds['your_variable']) regridded_nn.to_netcdf('output_nearest.nc')","title":"Example: Nearest Neighbor Regridding"},{"location":"how_to_regrid_xesmf_tutorial/#4-considerations","text":"","title":"4. Considerations"},{"location":"how_to_regrid_xesmf_tutorial/#working-with-large-datasets","text":"Regridding large datasets (e.g., high-resolution satellite data or long time series) can be memory- and compute-intensive. Here are some tips to improve performance: Use Dask for Chunking : xarray and xESMF support dask arrays, which allow you to process data in chunks and parallelize operations. Open your dataset with chunking: ```python ds = xr.open_dataset('input_data.nc', chunks={'time': 10, 'lat': 100, 'lon': 100})","title":"Working with Large Datasets"},{"location":"how_to_regrid_xesmf_tutorial/#adjust-chunk-sizes-to-fit-your-memory-and-data-shape","text":"``` Saving and Reusing Regridding Weights : When you create a regridder in xESMF, it computes a weight matrix that maps the source grid to the target grid. This computation can be slow for large grids, but you can save the weights to a file and reload them later for faster repeated regridding. Example: ```python","title":"Adjust chunk sizes to fit your memory and data shape"},{"location":"how_to_regrid_xesmf_tutorial/#first-time-compute-and-save-weights","text":"regridder = xe.Regridder(ds, target_grid, 'bilinear', filename='my_weights.nc')","title":"First time: compute and save weights"},{"location":"how_to_regrid_xesmf_tutorial/#next-time-reuse-the-saved-weights-much-faster","text":"regridder = xe.Regridder(ds, target_grid, 'bilinear', filename='my_weights.nc', reuse_weights=True) ``` This is especially useful when you need to regrid many variables or process data in chunks, as you only need to compute the weights once. Parallel Processing : If you have access to a cluster or multicore machine, dask can distribute the computation. Set up a dask cluster for even faster processing. Reduce Data Size : If possible, subset your data in time or space before regridding, or use coarser grids for exploratory analysis. Monitor Memory Usage : Large regridding operations can use a lot of RAM. Monitor your system and adjust chunk sizes or process data in smaller batches if needed. For more details, see the xESMF documentation on dask and performance .","title":"Next time: reuse the saved weights (much faster)"},{"location":"how_to_regrid_xesmf_tutorial/#5-visualizing-the-results","text":"import matplotlib.pyplot as plt regridded.plot() plt.title('Regridded Data (Bilinear)') plt.show()","title":"5. Visualizing the Results"},{"location":"how_to_regrid_xesmf_tutorial/#comparing-input-and-output","text":"You can compare the original and regridded data side by side: fig, axs = plt.subplots(1, 2, figsize=(12, 5)) ds['your_variable'].plot(ax=axs[0]) axs[0].set_title('Original Data') regridded.plot(ax=axs[1]) axs[1].set_title('Regridded Data (Bilinear)') plt.tight_layout() plt.show() For more advanced analysis, you can plot the difference: diff = regridded - ds['your_variable'].interp_like(regridded) diff.plot() plt.title('Difference After Regridding') plt.show()","title":"Comparing Input and Output"},{"location":"how_to_regrid_xesmf_tutorial/#6-references","text":"xESMF Documentation xarray Documentation This tutorial should help you get started with regridding 2D NetCDF datasets in Python using xESMF. Adjust the code to your specific data and needs!","title":"6. References"},{"location":"linux_cheat_sheet/","text":"Linux Command Line Cheat Sheet Author: Callum Introduction The Linux command line is a powerful tool for interacting with your computer. It allows you to navigate files, manage processes, and perform a wide range of tasks efficiently. Below are some essential commands and tips to get you started. How to Access the Command Line You can access the Linux command line in several ways, depending on your operating system and preferences: Terminal (Linux/macOS): Most Linux distributions and macOS have a built-in Terminal app. MobaXterm (Windows): A popular terminal emulator for Windows that provides SSH, SFTP, and more for connecting to Linux systems. Windows Subsystem for Linux (WSL): Allows you to run a Linux environment directly on Windows. Open via the Windows Terminal or the WSL app. VS Code Terminal: Visual Studio Code has an integrated terminal that can be used for command line access on any OS. PuTTY (Windows): Lightweight SSH client for connecting to remote Linux servers. Jupyter Notebooks: Some notebooks provide a terminal tab for command line access. Choose the method that best fits your workflow and system setup. Basic Navigation Command Description pwd Print current working directory ls List files and directories ls -l List with details (long format) ls -a List all files, including hidden cd <dir> Change directory to <dir> cd .. Go up one directory level cd ~ Go to your home directory mkdir <dir> Create a new directory rmdir <dir> Remove an empty directory touch <file> Create an empty file rm <file> Remove a file cp <src> <dest> Copy file or directory mv <src> <dest> Move or rename file/directory Viewing and Editing Files Command Description cat <file> Display file contents less <file> View file one page at a time head <file> Show first 10 lines of a file tail <file> Show last 10 lines of a file nano <file> Edit file with nano text editor vim <file> Edit file with vim text editor grep 'text' <file> Search for 'text' in a file System Info & Management Command Description whoami Show current user date Show current date and time df -h Show disk space usage du -sh <dir> Show size of a directory free -h Show memory usage top Show running processes ps aux List all running processes kill <pid> Kill process with process ID File Permissions Command Description chmod +x <file> Make file executable chmod 755 <file> Set permissions to rwxr-xr-x chown user:group <file> Change file owner and group Networking Command Description ping <host> Test network connection to host curl <url> Fetch content from a URL wget <url> Download file from a URL ssh user@host Connect to remote host via SSH Other Useful Commands Command Description history Show command history man <command> Show manual for a command echo \"text\" Print text to terminal tar -xzvf <file.tar.gz> Extract a tar.gz archive zip/unzip <file.zip> Compress or extract zip files Tips Use Tab for auto-completion. Use Ctrl+C to stop a running command. Use Ctrl+R to search command history. Use && to chain commands (run next if previous succeeds). For more, see the GNU Core Utilities Manual or run man <command> in your terminal.","title":"Linux Cheat Sheet"},{"location":"linux_cheat_sheet/#linux-command-line-cheat-sheet","text":"Author: Callum","title":"Linux Command Line Cheat Sheet"},{"location":"linux_cheat_sheet/#introduction","text":"The Linux command line is a powerful tool for interacting with your computer. It allows you to navigate files, manage processes, and perform a wide range of tasks efficiently. Below are some essential commands and tips to get you started.","title":"Introduction"},{"location":"linux_cheat_sheet/#how-to-access-the-command-line","text":"You can access the Linux command line in several ways, depending on your operating system and preferences: Terminal (Linux/macOS): Most Linux distributions and macOS have a built-in Terminal app. MobaXterm (Windows): A popular terminal emulator for Windows that provides SSH, SFTP, and more for connecting to Linux systems. Windows Subsystem for Linux (WSL): Allows you to run a Linux environment directly on Windows. Open via the Windows Terminal or the WSL app. VS Code Terminal: Visual Studio Code has an integrated terminal that can be used for command line access on any OS. PuTTY (Windows): Lightweight SSH client for connecting to remote Linux servers. Jupyter Notebooks: Some notebooks provide a terminal tab for command line access. Choose the method that best fits your workflow and system setup.","title":"How to Access the Command Line"},{"location":"linux_cheat_sheet/#basic-navigation","text":"Command Description pwd Print current working directory ls List files and directories ls -l List with details (long format) ls -a List all files, including hidden cd <dir> Change directory to <dir> cd .. Go up one directory level cd ~ Go to your home directory mkdir <dir> Create a new directory rmdir <dir> Remove an empty directory touch <file> Create an empty file rm <file> Remove a file cp <src> <dest> Copy file or directory mv <src> <dest> Move or rename file/directory","title":"Basic Navigation"},{"location":"linux_cheat_sheet/#viewing-and-editing-files","text":"Command Description cat <file> Display file contents less <file> View file one page at a time head <file> Show first 10 lines of a file tail <file> Show last 10 lines of a file nano <file> Edit file with nano text editor vim <file> Edit file with vim text editor grep 'text' <file> Search for 'text' in a file","title":"Viewing and Editing Files"},{"location":"linux_cheat_sheet/#system-info-management","text":"Command Description whoami Show current user date Show current date and time df -h Show disk space usage du -sh <dir> Show size of a directory free -h Show memory usage top Show running processes ps aux List all running processes kill <pid> Kill process with process ID","title":"System Info &amp; Management"},{"location":"linux_cheat_sheet/#file-permissions","text":"Command Description chmod +x <file> Make file executable chmod 755 <file> Set permissions to rwxr-xr-x chown user:group <file> Change file owner and group","title":"File Permissions"},{"location":"linux_cheat_sheet/#networking","text":"Command Description ping <host> Test network connection to host curl <url> Fetch content from a URL wget <url> Download file from a URL ssh user@host Connect to remote host via SSH","title":"Networking"},{"location":"linux_cheat_sheet/#other-useful-commands","text":"Command Description history Show command history man <command> Show manual for a command echo \"text\" Print text to terminal tar -xzvf <file.tar.gz> Extract a tar.gz archive zip/unzip <file.zip> Compress or extract zip files","title":"Other Useful Commands"},{"location":"linux_cheat_sheet/#tips","text":"Use Tab for auto-completion. Use Ctrl+C to stop a running command. Use Ctrl+R to search command history. Use && to chain commands (run next if previous succeeds). For more, see the GNU Core Utilities Manual or run man <command> in your terminal.","title":"Tips"},{"location":"printing/","text":"\ud83d\udda8\ufe0f Printing an A1 Poster on 4 Sheets of A3 Author: Elle This guide details how to split an A1 poster into four separate A3 PDF sheets for printing on University of Leeds printers. 1. Initial Setup in PowerPoint and PDF Creation Ensure your poster is correctly formatted as an A1 size document in PowerPoint . Go to the print dialogue. Select the PDF-XChange 5.0 for ABBYY printer option as shown in the image. Note: This acts as a virtual printer to convert the document. 2. Configuring Printer Properties to Split the A1 Page (Critical Step) Click on \"Printer Properties\" . Navigate to the \"Paper\" or \"Paper Settings\" tab. Set the Page Size to A1 (e.g., $594.0 \\times 841.0 \\text{ mm}$). In the \"Layout\" section, set the Sheet Size to A3 . Locate the Position boxes (X and Y coordinates) to define the four A3 sections. You must repeat the print/save process for each position. A1 Poster Split Coordinates A3 Page Section Position X (mm) Position Y (mm) Top-Left (Part 1) 0.0 0.0 Top-Right (Part 2) -297.0 0.0 Bottom-Left (Part 3) 0.0 -420.0 Bottom-Right (Part 4) -297.0 -420.0 Action: Print/Save as a separate PDF file (e.g., Poster_Part1.pdf ) after setting each coordinate pair. 3. Printing the A3 PDF Sheets To successfully print A3 on campus: You must be connected to the VPN . Open each of the four saved A3 PDFs (e.g., in a browser like Chrome). Initiate printing. Select the Staff on LeedsPrint print queue as the Destination . Click on \"More settings\" . Set the Paper size to A3 . Note: The user found this method more reliable than using the MyPrint portal. 4. Alternative Printing Options (If Laptop Fails) If printing from your personal laptop fails or the print queue is unavailable, you have other options: Use a wired computer in the library. Print through the Azure Virtual Desktop (AVD). (Refer to University IT services for up-to-date guidance on these options). 5. Assembly Each A3 sheet will print with a border . To create a fully joined-up A1 poster, you will need to cut the borders off and stick the four A3 sheets together with Sellotape.","title":"Printing A1"},{"location":"printing/#printing-an-a1-poster-on-4-sheets-of-a3","text":"Author: Elle This guide details how to split an A1 poster into four separate A3 PDF sheets for printing on University of Leeds printers.","title":"\ud83d\udda8\ufe0f Printing an A1 Poster on 4 Sheets of A3"},{"location":"printing/#1-initial-setup-in-powerpoint-and-pdf-creation","text":"Ensure your poster is correctly formatted as an A1 size document in PowerPoint . Go to the print dialogue. Select the PDF-XChange 5.0 for ABBYY printer option as shown in the image. Note: This acts as a virtual printer to convert the document.","title":"1. Initial Setup in PowerPoint and PDF Creation"},{"location":"printing/#2-configuring-printer-properties-to-split-the-a1-page-critical-step","text":"Click on \"Printer Properties\" . Navigate to the \"Paper\" or \"Paper Settings\" tab. Set the Page Size to A1 (e.g., $594.0 \\times 841.0 \\text{ mm}$). In the \"Layout\" section, set the Sheet Size to A3 . Locate the Position boxes (X and Y coordinates) to define the four A3 sections. You must repeat the print/save process for each position.","title":"2. Configuring Printer Properties to Split the A1 Page (Critical Step)"},{"location":"printing/#a1-poster-split-coordinates","text":"A3 Page Section Position X (mm) Position Y (mm) Top-Left (Part 1) 0.0 0.0 Top-Right (Part 2) -297.0 0.0 Bottom-Left (Part 3) 0.0 -420.0 Bottom-Right (Part 4) -297.0 -420.0 Action: Print/Save as a separate PDF file (e.g., Poster_Part1.pdf ) after setting each coordinate pair.","title":"A1 Poster Split Coordinates"},{"location":"printing/#3-printing-the-a3-pdf-sheets","text":"To successfully print A3 on campus: You must be connected to the VPN . Open each of the four saved A3 PDFs (e.g., in a browser like Chrome). Initiate printing. Select the Staff on LeedsPrint print queue as the Destination . Click on \"More settings\" . Set the Paper size to A3 . Note: The user found this method more reliable than using the MyPrint portal.","title":"3. Printing the A3 PDF Sheets"},{"location":"printing/#4-alternative-printing-options-if-laptop-fails","text":"If printing from your personal laptop fails or the print queue is unavailable, you have other options: Use a wired computer in the library. Print through the Azure Virtual Desktop (AVD). (Refer to University IT services for up-to-date guidance on these options).","title":"4. Alternative Printing Options (If Laptop Fails)"},{"location":"printing/#5-assembly","text":"Each A3 sheet will print with a border . To create a fully joined-up A1 poster, you will need to cut the borders off and stick the four A3 sheets together with Sellotape.","title":"5. Assembly"},{"location":"python_quick_start/","text":"Python Quick Start Guide Author: Callum Introduction Python is a powerful, easy-to-learn programming language widely used in science, data analysis, web development, automation, and more. This guide will help beginners get started with Python, focusing on best practices for installation, environment management, and basic usage. For scientific and data work, using Conda (or Mamba) is highly recommended\u2014see the Conda Setup Guide for details. Opening a Terminal To use Python and Conda/Mamba, you'll need to open a terminal (command line window) on your computer: Windows: If you have Windows Subsystem for Linux (WSL) installed, open the Start menu, search for \"WSL\" or your chosen Linux distribution (e.g., Ubuntu), and click to open a Linux terminal. Alternatively, use MobaXterm : install it, then open MobaXterm and start a local terminal or a WSL session. Mac: Open the Terminal app (find it in Applications > Utilities, or search for \"Terminal\" in Spotlight). Linux: Open your system's Terminal app (often found in the applications menu, or use Ctrl+Alt+T as a shortcut). Once your terminal is open, you can follow the steps below to install Python, set up environments, and run code. Why Use Python? Simple, readable syntax Large ecosystem of libraries for every purpose Excellent for beginners and experts alike Strong community support Step 1: Install Python (Recommended: via Conda/Mamba) While you can install Python directly from python.org, the best way for scientific work is to use Conda or Mamba. This lets you easily manage multiple Python versions and install packages without conflicts. See the Conda Setup Guide for step-by-step instructions. Step 2: Create a Python Environment Environments keep your projects isolated, so packages for one project don\u2019t interfere with another. mamba create -n mypython python=3.11 mamba activate mypython Step 3: Install Packages Use Mamba (or Conda) to install packages from the conda-forge channel. This ensures compatibility and avoids dependency issues. mamba install numpy pandas matplotlib Step 4: Write and Run Python Code You can write Python code in a text editor (like VS Code) and run it from the terminal: python myscript.py Or use interactive notebooks (Jupyter) for data analysis: mamba install jupyterlab jupyter lab Step 5: Learn the Basics Here are some key concepts for beginners: - Variables : Store data (numbers, text, etc.) - Data types : int, float, str, list, dict, etc. - Control flow : if, for, while - Functions : Reusable blocks of code - Modules : Import libraries to extend Python\u2019s capabilities Example: # myscript.py name = \"World\" print(f\"Hello, {name}!\") Best Practices Always use environments for your projects Prefer conda-forge for package installs Keep your Python and packages up to date Use version control (e.g., git) for your code Read error messages\u2014they help you debug! Useful Resources Conda Setup Guide Python Official Documentation Real Python Tutorials Jupyter Project Troubleshooting If you have issues with packages, check you\u2019re using conda-forge and not mixing channels If Python isn\u2019t found, make sure your environment is activated For help, search error messages or ask the community Python is a great language for learning and doing real-world work. With Conda/Mamba and conda-forge, you\u2019ll avoid most installation headaches and be ready to explore!","title":"Python Quick Start"},{"location":"python_quick_start/#python-quick-start-guide","text":"Author: Callum","title":"Python Quick Start Guide"},{"location":"python_quick_start/#introduction","text":"Python is a powerful, easy-to-learn programming language widely used in science, data analysis, web development, automation, and more. This guide will help beginners get started with Python, focusing on best practices for installation, environment management, and basic usage. For scientific and data work, using Conda (or Mamba) is highly recommended\u2014see the Conda Setup Guide for details.","title":"Introduction"},{"location":"python_quick_start/#opening-a-terminal","text":"To use Python and Conda/Mamba, you'll need to open a terminal (command line window) on your computer: Windows: If you have Windows Subsystem for Linux (WSL) installed, open the Start menu, search for \"WSL\" or your chosen Linux distribution (e.g., Ubuntu), and click to open a Linux terminal. Alternatively, use MobaXterm : install it, then open MobaXterm and start a local terminal or a WSL session. Mac: Open the Terminal app (find it in Applications > Utilities, or search for \"Terminal\" in Spotlight). Linux: Open your system's Terminal app (often found in the applications menu, or use Ctrl+Alt+T as a shortcut). Once your terminal is open, you can follow the steps below to install Python, set up environments, and run code.","title":"Opening a Terminal"},{"location":"python_quick_start/#why-use-python","text":"Simple, readable syntax Large ecosystem of libraries for every purpose Excellent for beginners and experts alike Strong community support","title":"Why Use Python?"},{"location":"python_quick_start/#step-1-install-python-recommended-via-condamamba","text":"While you can install Python directly from python.org, the best way for scientific work is to use Conda or Mamba. This lets you easily manage multiple Python versions and install packages without conflicts. See the Conda Setup Guide for step-by-step instructions.","title":"Step 1: Install Python (Recommended: via Conda/Mamba)"},{"location":"python_quick_start/#step-2-create-a-python-environment","text":"Environments keep your projects isolated, so packages for one project don\u2019t interfere with another. mamba create -n mypython python=3.11 mamba activate mypython","title":"Step 2: Create a Python Environment"},{"location":"python_quick_start/#step-3-install-packages","text":"Use Mamba (or Conda) to install packages from the conda-forge channel. This ensures compatibility and avoids dependency issues. mamba install numpy pandas matplotlib","title":"Step 3: Install Packages"},{"location":"python_quick_start/#step-4-write-and-run-python-code","text":"You can write Python code in a text editor (like VS Code) and run it from the terminal: python myscript.py Or use interactive notebooks (Jupyter) for data analysis: mamba install jupyterlab jupyter lab","title":"Step 4: Write and Run Python Code"},{"location":"python_quick_start/#step-5-learn-the-basics","text":"Here are some key concepts for beginners: - Variables : Store data (numbers, text, etc.) - Data types : int, float, str, list, dict, etc. - Control flow : if, for, while - Functions : Reusable blocks of code - Modules : Import libraries to extend Python\u2019s capabilities Example: # myscript.py name = \"World\" print(f\"Hello, {name}!\")","title":"Step 5: Learn the Basics"},{"location":"python_quick_start/#best-practices","text":"Always use environments for your projects Prefer conda-forge for package installs Keep your Python and packages up to date Use version control (e.g., git) for your code Read error messages\u2014they help you debug!","title":"Best Practices"},{"location":"python_quick_start/#useful-resources","text":"Conda Setup Guide Python Official Documentation Real Python Tutorials Jupyter Project","title":"Useful Resources"},{"location":"python_quick_start/#troubleshooting","text":"If you have issues with packages, check you\u2019re using conda-forge and not mixing channels If Python isn\u2019t found, make sure your environment is activated For help, search error messages or ask the community Python is a great language for learning and doing real-world work. With Conda/Mamba and conda-forge, you\u2019ll avoid most installation headaches and be ready to explore!","title":"Troubleshooting"}]}