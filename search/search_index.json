{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the BAG Wiki! This is a wiki for Leeds Biosphere and Atmosphere Group (BAG) to share computing and technical guides and tips","title":"Home"},{"location":"#welcome-to-the-bag-wiki","text":"This is a wiki for Leeds Biosphere and Atmosphere Group (BAG) to share computing and technical guides and tips","title":"Welcome to the BAG Wiki!"},{"location":"contributing/","text":"Contributing Thank you for contributing! Use this short checklist: Create or update a Markdown file in docs/ Use headings and short sections for readability Add images to docs/images/ and reference with relative paths Submit a branch and open a PR against main Suggested PR title format: \"docs: add/modify \" Template for a new how-to: # Short title ## Why Brief reason / context. ## Steps 1. Step one 2. Step two ## Notes - Extra tips or links","title":"Contributing"},{"location":"contributing/#contributing","text":"Thank you for contributing! Use this short checklist: Create or update a Markdown file in docs/ Use headings and short sections for readability Add images to docs/images/ and reference with relative paths Submit a branch and open a PR against main Suggested PR title format: \"docs: add/modify \" Template for a new how-to: # Short title ## Why Brief reason / context. ## Steps 1. Step one 2. Step two ## Notes - Extra tips or links","title":"Contributing"},{"location":"how-to-example/","text":"Example how-to This is an example how-to page. Replace with actual content. Background Short context. Steps Do A Do B Troubleshooting If X happens, try Y.","title":"Example how-to"},{"location":"how-to-example/#example-how-to","text":"This is an example how-to page. Replace with actual content.","title":"Example how-to"},{"location":"how-to-example/#background","text":"Short context.","title":"Background"},{"location":"how-to-example/#steps","text":"Do A Do B","title":"Steps"},{"location":"how-to-example/#troubleshooting","text":"If X happens, try Y.","title":"Troubleshooting"},{"location":"how_to_regrid_xesmf_tutorial/","text":"Tutorial: Regridding 2D NetCDF Datasets in Python with xESMF Regridding (also called remapping or resampling) is a common task in geosciences, especially when working with gridded data such as satellite or climate model outputs. The goal is to interpolate data from one grid to another, which is essential for comparing datasets, combining products, or preparing data for models. In this tutorial, we'll use the Python package xESMF to regrid 2D NetCDF datasets. xESMF is built on top of xarray and ESMF, providing a simple interface for regridding with various algorithms. Prerequisites Install the required packages: mamba install xarray xesmf 1. Loading a NetCDF Dataset We'll use xarray to open NetCDF files. Here, we assume you have a 2D variable (e.g., satellite data) with latitude and longitude coordinates. import xarray as xr ds = xr.open_dataset('input_data.nc') print(ds) Plotting the Input Data import matplotlib.pyplot as plt ds['your_variable'].plot() plt.title('Original Data on Source Grid') plt.show() 2. Defining the Target Grid You need to define the grid you want to regrid to. This can be another dataset's grid, or you can create a new one. Here, we create a regular lat/lon grid: import numpy as np target_grid = xr.Dataset({ 'lat': (['lat'], np.arange(-90, 90.1, 1.0)), 'lon': (['lon'], np.arange(0, 360, 1.0)), }) Visualizing the Target Grid plt.figure() plt.scatter(target_grid['lon'], target_grid['lat'], s=1) plt.xlabel('Longitude') plt.ylabel('Latitude') plt.title('Target Grid Points') plt.show() 3. Regridding with xESMF xESMF supports several regridding methods: Choosing a Regridding Algorithm The choice of algorithm depends on your data and scientific goals: Bilinear : Uses weighted averages of the four nearest grid points. It is smooth and works well for continuous variables (e.g., temperature, pressure). However, it does not conserve the total sum of the variable, so it is not suitable for fluxes or quantities where conservation is important. Conservative : Ensures that the integral (sum) of the variable is preserved during regridding. This is essential for variables like precipitation, runoff, or any fluxes. It requires both source and target grids to define cell boundaries (i.e., grid must be defined by cell centers and edges). It can be sensitive to missing values (NaNs), which may cause the output to be NaN if any input cell is NaN. Conservative-normed : Similar to conservative, but normalizes the weights so that if some source cells are NaN, the valid part of the cell is still used. This is especially useful for satellite data or observational products with missing values, as it avoids propagating NaNs unnecessarily. Use this when you want conservation but need to handle missing data robustly. Nearest_s2d / nearest_d2s : Assigns the value of the nearest source (or destination) grid cell. This is fast and preserves original values, but can introduce blocky artifacts. Use for categorical data (e.g., land/sea masks, land cover types) or when you want to avoid interpolation. Patch : A higher-order method that can provide smoother results for some variables, but is less commonly used and more computationally intensive. Summary Table Algorithm Preserves Integrals Handles NaNs Well Smooth Use For bilinear No Moderate Yes Continuous fields conservative Yes No No Fluxes, precipitation conservative-normed Yes Yes No Fluxes with missing data nearest_s2d/d2s No Yes No Categorical, masks patch No Moderate Yes Advanced, smooth fields Example: Bilinear Regridding import xesmf as xe regridder = xe.Regridder(ds, target_grid, 'bilinear') regridded = regridder(ds['your_variable']) regridded.to_netcdf('output_bilinear.nc') Example: Conservative Regridding regridder_cons = xe.Regridder(ds, target_grid, 'conservative') regridded_cons = regridder_cons(ds['your_variable']) regridded_cons.to_netcdf('output_conservative.nc') Example: Conservative-normed Regridding The conservative-normed method is designed to handle missing values (NaNs) more robustly than standard conservative regridding. In the standard conservative method, if any part of a source cell is NaN, the entire destination cell may become NaN. The conservative-normed method normalizes the weights so that only the valid (non-NaN) fraction of the source cell contributes to the destination cell, preventing unnecessary propagation of NaNs. Using a 'mask' Layer To take full advantage of conservative-normed, you should provide a mask variable in your xarray dataset. This mask should be a DataArray with the same shape as your data, where valid data points are marked as 1 (or True) and missing/invalid points as 0 (or False). xESMF will use this mask to determine which parts of the grid are valid during regridding. Example of adding a mask: import numpy as np # Suppose ds['your_variable'] contains NaNs for missing data mask = (~np.isnan(ds['your_variable'])).astype(int) ds['mask'] = (ds['your_variable'].dims, mask) # Now use conservative-normed regridder_normed = xe.Regridder(ds, target_grid, 'conservative_normed') regridded_normed = regridder_normed(ds['your_variable']) regridded_normed.to_netcdf('output_conservative_normed.nc') If you do not provide a mask, xESMF will infer it from the NaN pattern in your data, but explicitly providing a mask is more robust and recommended for complex or irregular missing data patterns. For more, see the xESMF documentation on masking . Example: Nearest Neighbor Regridding regridder_nn = xe.Regridder(ds, target_grid, 'nearest_s2d') regridded_nn = regridder_nn(ds['your_variable']) regridded_nn.to_netcdf('output_nearest.nc') 4. Considerations Working with Large Datasets Regridding large datasets (e.g., high-resolution satellite data or long time series) can be memory- and compute-intensive. Here are some tips to improve performance: Use Dask for Chunking : xarray and xESMF support dask arrays, which allow you to process data in chunks and parallelize operations. Open your dataset with chunking: ```python ds = xr.open_dataset('input_data.nc', chunks={'time': 10, 'lat': 100, 'lon': 100}) Adjust chunk sizes to fit your memory and data shape ``` Saving and Reusing Regridding Weights : When you create a regridder in xESMF, it computes a weight matrix that maps the source grid to the target grid. This computation can be slow for large grids, but you can save the weights to a file and reload them later for faster repeated regridding. Example: ```python First time: compute and save weights regridder = xe.Regridder(ds, target_grid, 'bilinear', filename='my_weights.nc') Next time: reuse the saved weights (much faster) regridder = xe.Regridder(ds, target_grid, 'bilinear', filename='my_weights.nc', reuse_weights=True) ``` This is especially useful when you need to regrid many variables or process data in chunks, as you only need to compute the weights once. Parallel Processing : If you have access to a cluster or multicore machine, dask can distribute the computation. Set up a dask cluster for even faster processing. Reduce Data Size : If possible, subset your data in time or space before regridding, or use coarser grids for exploratory analysis. Monitor Memory Usage : Large regridding operations can use a lot of RAM. Monitor your system and adjust chunk sizes or process data in smaller batches if needed. For more details, see the xESMF documentation on dask and performance . 5. Visualizing the Results import matplotlib.pyplot as plt regridded.plot() plt.title('Regridded Data (Bilinear)') plt.show() Comparing Input and Output You can compare the original and regridded data side by side: fig, axs = plt.subplots(1, 2, figsize=(12, 5)) ds['your_variable'].plot(ax=axs[0]) axs[0].set_title('Original Data') regridded.plot(ax=axs[1]) axs[1].set_title('Regridded Data (Bilinear)') plt.tight_layout() plt.show() For more advanced analysis, you can plot the difference: diff = regridded - ds['your_variable'].interp_like(regridded) diff.plot() plt.title('Difference After Regridding') plt.show() 6. References xESMF Documentation xarray Documentation This tutorial should help you get started with regridding 2D NetCDF datasets in Python using xESMF. Adjust the code to your specific data and needs!","title":"Regridding with Python"},{"location":"how_to_regrid_xesmf_tutorial/#tutorial-regridding-2d-netcdf-datasets-in-python-with-xesmf","text":"Regridding (also called remapping or resampling) is a common task in geosciences, especially when working with gridded data such as satellite or climate model outputs. The goal is to interpolate data from one grid to another, which is essential for comparing datasets, combining products, or preparing data for models. In this tutorial, we'll use the Python package xESMF to regrid 2D NetCDF datasets. xESMF is built on top of xarray and ESMF, providing a simple interface for regridding with various algorithms.","title":"Tutorial: Regridding 2D NetCDF Datasets in Python with xESMF"},{"location":"how_to_regrid_xesmf_tutorial/#prerequisites","text":"Install the required packages: mamba install xarray xesmf","title":"Prerequisites"},{"location":"how_to_regrid_xesmf_tutorial/#1-loading-a-netcdf-dataset","text":"We'll use xarray to open NetCDF files. Here, we assume you have a 2D variable (e.g., satellite data) with latitude and longitude coordinates. import xarray as xr ds = xr.open_dataset('input_data.nc') print(ds)","title":"1. Loading a NetCDF Dataset"},{"location":"how_to_regrid_xesmf_tutorial/#plotting-the-input-data","text":"import matplotlib.pyplot as plt ds['your_variable'].plot() plt.title('Original Data on Source Grid') plt.show()","title":"Plotting the Input Data"},{"location":"how_to_regrid_xesmf_tutorial/#2-defining-the-target-grid","text":"You need to define the grid you want to regrid to. This can be another dataset's grid, or you can create a new one. Here, we create a regular lat/lon grid: import numpy as np target_grid = xr.Dataset({ 'lat': (['lat'], np.arange(-90, 90.1, 1.0)), 'lon': (['lon'], np.arange(0, 360, 1.0)), })","title":"2. Defining the Target Grid"},{"location":"how_to_regrid_xesmf_tutorial/#visualizing-the-target-grid","text":"plt.figure() plt.scatter(target_grid['lon'], target_grid['lat'], s=1) plt.xlabel('Longitude') plt.ylabel('Latitude') plt.title('Target Grid Points') plt.show()","title":"Visualizing the Target Grid"},{"location":"how_to_regrid_xesmf_tutorial/#3-regridding-with-xesmf","text":"xESMF supports several regridding methods:","title":"3. Regridding with xESMF"},{"location":"how_to_regrid_xesmf_tutorial/#choosing-a-regridding-algorithm","text":"The choice of algorithm depends on your data and scientific goals: Bilinear : Uses weighted averages of the four nearest grid points. It is smooth and works well for continuous variables (e.g., temperature, pressure). However, it does not conserve the total sum of the variable, so it is not suitable for fluxes or quantities where conservation is important. Conservative : Ensures that the integral (sum) of the variable is preserved during regridding. This is essential for variables like precipitation, runoff, or any fluxes. It requires both source and target grids to define cell boundaries (i.e., grid must be defined by cell centers and edges). It can be sensitive to missing values (NaNs), which may cause the output to be NaN if any input cell is NaN. Conservative-normed : Similar to conservative, but normalizes the weights so that if some source cells are NaN, the valid part of the cell is still used. This is especially useful for satellite data or observational products with missing values, as it avoids propagating NaNs unnecessarily. Use this when you want conservation but need to handle missing data robustly. Nearest_s2d / nearest_d2s : Assigns the value of the nearest source (or destination) grid cell. This is fast and preserves original values, but can introduce blocky artifacts. Use for categorical data (e.g., land/sea masks, land cover types) or when you want to avoid interpolation. Patch : A higher-order method that can provide smoother results for some variables, but is less commonly used and more computationally intensive.","title":"Choosing a Regridding Algorithm"},{"location":"how_to_regrid_xesmf_tutorial/#summary-table","text":"Algorithm Preserves Integrals Handles NaNs Well Smooth Use For bilinear No Moderate Yes Continuous fields conservative Yes No No Fluxes, precipitation conservative-normed Yes Yes No Fluxes with missing data nearest_s2d/d2s No Yes No Categorical, masks patch No Moderate Yes Advanced, smooth fields","title":"Summary Table"},{"location":"how_to_regrid_xesmf_tutorial/#example-bilinear-regridding","text":"import xesmf as xe regridder = xe.Regridder(ds, target_grid, 'bilinear') regridded = regridder(ds['your_variable']) regridded.to_netcdf('output_bilinear.nc')","title":"Example: Bilinear Regridding"},{"location":"how_to_regrid_xesmf_tutorial/#example-conservative-regridding","text":"regridder_cons = xe.Regridder(ds, target_grid, 'conservative') regridded_cons = regridder_cons(ds['your_variable']) regridded_cons.to_netcdf('output_conservative.nc')","title":"Example: Conservative Regridding"},{"location":"how_to_regrid_xesmf_tutorial/#example-conservative-normed-regridding","text":"The conservative-normed method is designed to handle missing values (NaNs) more robustly than standard conservative regridding. In the standard conservative method, if any part of a source cell is NaN, the entire destination cell may become NaN. The conservative-normed method normalizes the weights so that only the valid (non-NaN) fraction of the source cell contributes to the destination cell, preventing unnecessary propagation of NaNs.","title":"Example: Conservative-normed Regridding"},{"location":"how_to_regrid_xesmf_tutorial/#using-a-mask-layer","text":"To take full advantage of conservative-normed, you should provide a mask variable in your xarray dataset. This mask should be a DataArray with the same shape as your data, where valid data points are marked as 1 (or True) and missing/invalid points as 0 (or False). xESMF will use this mask to determine which parts of the grid are valid during regridding. Example of adding a mask: import numpy as np # Suppose ds['your_variable'] contains NaNs for missing data mask = (~np.isnan(ds['your_variable'])).astype(int) ds['mask'] = (ds['your_variable'].dims, mask) # Now use conservative-normed regridder_normed = xe.Regridder(ds, target_grid, 'conservative_normed') regridded_normed = regridder_normed(ds['your_variable']) regridded_normed.to_netcdf('output_conservative_normed.nc') If you do not provide a mask, xESMF will infer it from the NaN pattern in your data, but explicitly providing a mask is more robust and recommended for complex or irregular missing data patterns. For more, see the xESMF documentation on masking .","title":"Using a 'mask' Layer"},{"location":"how_to_regrid_xesmf_tutorial/#example-nearest-neighbor-regridding","text":"regridder_nn = xe.Regridder(ds, target_grid, 'nearest_s2d') regridded_nn = regridder_nn(ds['your_variable']) regridded_nn.to_netcdf('output_nearest.nc')","title":"Example: Nearest Neighbor Regridding"},{"location":"how_to_regrid_xesmf_tutorial/#4-considerations","text":"","title":"4. Considerations"},{"location":"how_to_regrid_xesmf_tutorial/#working-with-large-datasets","text":"Regridding large datasets (e.g., high-resolution satellite data or long time series) can be memory- and compute-intensive. Here are some tips to improve performance: Use Dask for Chunking : xarray and xESMF support dask arrays, which allow you to process data in chunks and parallelize operations. Open your dataset with chunking: ```python ds = xr.open_dataset('input_data.nc', chunks={'time': 10, 'lat': 100, 'lon': 100})","title":"Working with Large Datasets"},{"location":"how_to_regrid_xesmf_tutorial/#adjust-chunk-sizes-to-fit-your-memory-and-data-shape","text":"``` Saving and Reusing Regridding Weights : When you create a regridder in xESMF, it computes a weight matrix that maps the source grid to the target grid. This computation can be slow for large grids, but you can save the weights to a file and reload them later for faster repeated regridding. Example: ```python","title":"Adjust chunk sizes to fit your memory and data shape"},{"location":"how_to_regrid_xesmf_tutorial/#first-time-compute-and-save-weights","text":"regridder = xe.Regridder(ds, target_grid, 'bilinear', filename='my_weights.nc')","title":"First time: compute and save weights"},{"location":"how_to_regrid_xesmf_tutorial/#next-time-reuse-the-saved-weights-much-faster","text":"regridder = xe.Regridder(ds, target_grid, 'bilinear', filename='my_weights.nc', reuse_weights=True) ``` This is especially useful when you need to regrid many variables or process data in chunks, as you only need to compute the weights once. Parallel Processing : If you have access to a cluster or multicore machine, dask can distribute the computation. Set up a dask cluster for even faster processing. Reduce Data Size : If possible, subset your data in time or space before regridding, or use coarser grids for exploratory analysis. Monitor Memory Usage : Large regridding operations can use a lot of RAM. Monitor your system and adjust chunk sizes or process data in smaller batches if needed. For more details, see the xESMF documentation on dask and performance .","title":"Next time: reuse the saved weights (much faster)"},{"location":"how_to_regrid_xesmf_tutorial/#5-visualizing-the-results","text":"import matplotlib.pyplot as plt regridded.plot() plt.title('Regridded Data (Bilinear)') plt.show()","title":"5. Visualizing the Results"},{"location":"how_to_regrid_xesmf_tutorial/#comparing-input-and-output","text":"You can compare the original and regridded data side by side: fig, axs = plt.subplots(1, 2, figsize=(12, 5)) ds['your_variable'].plot(ax=axs[0]) axs[0].set_title('Original Data') regridded.plot(ax=axs[1]) axs[1].set_title('Regridded Data (Bilinear)') plt.tight_layout() plt.show() For more advanced analysis, you can plot the difference: diff = regridded - ds['your_variable'].interp_like(regridded) diff.plot() plt.title('Difference After Regridding') plt.show()","title":"Comparing Input and Output"},{"location":"how_to_regrid_xesmf_tutorial/#6-references","text":"xESMF Documentation xarray Documentation This tutorial should help you get started with regridding 2D NetCDF datasets in Python using xESMF. Adjust the code to your specific data and needs!","title":"6. References"},{"location":"linux_cheat_sheet/","text":"Linux Command Line Cheat Sheet Introduction The Linux command line is a powerful tool for interacting with your computer. It allows you to navigate files, manage processes, and perform a wide range of tasks efficiently. Below are some essential commands and tips to get you started. How to Access the Command Line You can access the Linux command line in several ways, depending on your operating system and preferences: Terminal (Linux/macOS): Most Linux distributions and macOS have a built-in Terminal app. MobaXterm (Windows): A popular terminal emulator for Windows that provides SSH, SFTP, and more for connecting to Linux systems. Windows Subsystem for Linux (WSL): Allows you to run a Linux environment directly on Windows. Open via the Windows Terminal or the WSL app. VS Code Terminal: Visual Studio Code has an integrated terminal that can be used for command line access on any OS. PuTTY (Windows): Lightweight SSH client for connecting to remote Linux servers. Jupyter Notebooks: Some notebooks provide a terminal tab for command line access. Choose the method that best fits your workflow and system setup. Basic Navigation Command Description pwd Print current working directory ls List files and directories ls -l List with details (long format) ls -a List all files, including hidden cd <dir> Change directory to <dir> cd .. Go up one directory level cd ~ Go to your home directory mkdir <dir> Create a new directory rmdir <dir> Remove an empty directory touch <file> Create an empty file rm <file> Remove a file cp <src> <dest> Copy file or directory mv <src> <dest> Move or rename file/directory Viewing and Editing Files Command Description cat <file> Display file contents less <file> View file one page at a time head <file> Show first 10 lines of a file tail <file> Show last 10 lines of a file nano <file> Edit file with nano text editor vim <file> Edit file with vim text editor grep 'text' <file> Search for 'text' in a file System Info & Management Command Description whoami Show current user date Show current date and time df -h Show disk space usage du -sh <dir> Show size of a directory free -h Show memory usage top Show running processes ps aux List all running processes kill <pid> Kill process with process ID File Permissions Command Description chmod +x <file> Make file executable chmod 755 <file> Set permissions to rwxr-xr-x chown user:group <file> Change file owner and group Networking Command Description ping <host> Test network connection to host curl <url> Fetch content from a URL wget <url> Download file from a URL ssh user@host Connect to remote host via SSH Other Useful Commands Command Description history Show command history man <command> Show manual for a command echo \"text\" Print text to terminal tar -xzvf <file.tar.gz> Extract a tar.gz archive zip/unzip <file.zip> Compress or extract zip files Tips Use Tab for auto-completion. Use Ctrl+C to stop a running command. Use Ctrl+R to search command history. Use && to chain commands (run next if previous succeeds). For more, see the GNU Core Utilities Manual or run man <command> in your terminal.","title":"Linux Cheat Sheet"},{"location":"linux_cheat_sheet/#linux-command-line-cheat-sheet","text":"","title":"Linux Command Line Cheat Sheet"},{"location":"linux_cheat_sheet/#introduction","text":"The Linux command line is a powerful tool for interacting with your computer. It allows you to navigate files, manage processes, and perform a wide range of tasks efficiently. Below are some essential commands and tips to get you started.","title":"Introduction"},{"location":"linux_cheat_sheet/#how-to-access-the-command-line","text":"You can access the Linux command line in several ways, depending on your operating system and preferences: Terminal (Linux/macOS): Most Linux distributions and macOS have a built-in Terminal app. MobaXterm (Windows): A popular terminal emulator for Windows that provides SSH, SFTP, and more for connecting to Linux systems. Windows Subsystem for Linux (WSL): Allows you to run a Linux environment directly on Windows. Open via the Windows Terminal or the WSL app. VS Code Terminal: Visual Studio Code has an integrated terminal that can be used for command line access on any OS. PuTTY (Windows): Lightweight SSH client for connecting to remote Linux servers. Jupyter Notebooks: Some notebooks provide a terminal tab for command line access. Choose the method that best fits your workflow and system setup.","title":"How to Access the Command Line"},{"location":"linux_cheat_sheet/#basic-navigation","text":"Command Description pwd Print current working directory ls List files and directories ls -l List with details (long format) ls -a List all files, including hidden cd <dir> Change directory to <dir> cd .. Go up one directory level cd ~ Go to your home directory mkdir <dir> Create a new directory rmdir <dir> Remove an empty directory touch <file> Create an empty file rm <file> Remove a file cp <src> <dest> Copy file or directory mv <src> <dest> Move or rename file/directory","title":"Basic Navigation"},{"location":"linux_cheat_sheet/#viewing-and-editing-files","text":"Command Description cat <file> Display file contents less <file> View file one page at a time head <file> Show first 10 lines of a file tail <file> Show last 10 lines of a file nano <file> Edit file with nano text editor vim <file> Edit file with vim text editor grep 'text' <file> Search for 'text' in a file","title":"Viewing and Editing Files"},{"location":"linux_cheat_sheet/#system-info-management","text":"Command Description whoami Show current user date Show current date and time df -h Show disk space usage du -sh <dir> Show size of a directory free -h Show memory usage top Show running processes ps aux List all running processes kill <pid> Kill process with process ID","title":"System Info &amp; Management"},{"location":"linux_cheat_sheet/#file-permissions","text":"Command Description chmod +x <file> Make file executable chmod 755 <file> Set permissions to rwxr-xr-x chown user:group <file> Change file owner and group","title":"File Permissions"},{"location":"linux_cheat_sheet/#networking","text":"Command Description ping <host> Test network connection to host curl <url> Fetch content from a URL wget <url> Download file from a URL ssh user@host Connect to remote host via SSH","title":"Networking"},{"location":"linux_cheat_sheet/#other-useful-commands","text":"Command Description history Show command history man <command> Show manual for a command echo \"text\" Print text to terminal tar -xzvf <file.tar.gz> Extract a tar.gz archive zip/unzip <file.zip> Compress or extract zip files","title":"Other Useful Commands"},{"location":"linux_cheat_sheet/#tips","text":"Use Tab for auto-completion. Use Ctrl+C to stop a running command. Use Ctrl+R to search command history. Use && to chain commands (run next if previous succeeds). For more, see the GNU Core Utilities Manual or run man <command> in your terminal.","title":"Tips"}]}