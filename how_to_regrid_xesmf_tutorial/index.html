<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Leeds BAG" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Regridding with Python - Leeds BAG Wiki</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Regridding with Python";
        var mkdocs_page_input_path = "how_to_regrid_xesmf_tutorial.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> Leeds BAG Wiki
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">How-to guides</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../linux_cheat_sheet/">Linux Cheat Sheet</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">Regridding with Python</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#prerequisites">Prerequisites</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#1-loading-a-netcdf-dataset">1. Loading a NetCDF Dataset</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#plotting-the-input-data">Plotting the Input Data</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#2-defining-the-target-grid">2. Defining the Target Grid</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#visualizing-the-target-grid">Visualizing the Target Grid</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#3-regridding-with-xesmf">3. Regridding with xESMF</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#choosing-a-regridding-algorithm">Choosing a Regridding Algorithm</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#summary-table">Summary Table</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#example-bilinear-regridding">Example: Bilinear Regridding</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#example-conservative-regridding">Example: Conservative Regridding</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#example-conservative-normed-regridding">Example: Conservative-normed Regridding</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#using-a-mask-layer">Using a 'mask' Layer</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#example-nearest-neighbor-regridding">Example: Nearest Neighbor Regridding</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#4-considerations">4. Considerations</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#working-with-large-datasets">Working with Large Datasets</a>
    </li>
        </ul>
    </li>
    </ul>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">Leeds BAG Wiki</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">How-to guides</li>
      <li class="breadcrumb-item active">Regridding with Python</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/leeds-bag/bag_wiki/edit/main/docs/how_to_regrid_xesmf_tutorial.md">Edit on leeds-bag/bag_wiki</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="tutorial-regridding-2d-netcdf-datasets-in-python-with-xesmf">Tutorial: Regridding 2D NetCDF Datasets in Python with xESMF</h1>
<p>Regridding (also called remapping or resampling) is a common task in geosciences, especially when working with gridded data such as satellite or climate model outputs. The goal is to interpolate data from one grid to another, which is essential for comparing datasets, combining products, or preparing data for models.</p>
<p>In this tutorial, we'll use the Python package <strong>xESMF</strong> to regrid 2D NetCDF datasets. xESMF is built on top of xarray and ESMF, providing a simple interface for regridding with various algorithms.</p>
<h2 id="prerequisites">Prerequisites</h2>
<p>Install the required packages:</p>
<pre><code class="language-bash">mamba install xarray xesmf
</code></pre>
<h2 id="1-loading-a-netcdf-dataset">1. Loading a NetCDF Dataset</h2>
<p>We'll use xarray to open NetCDF files. Here, we assume you have a 2D variable (e.g., satellite data) with latitude and longitude coordinates.</p>
<pre><code class="language-python">import xarray as xr

ds = xr.open_dataset('input_data.nc')
print(ds)
</code></pre>
<h3 id="plotting-the-input-data">Plotting the Input Data</h3>
<pre><code class="language-python">import matplotlib.pyplot as plt

ds['your_variable'].plot()
plt.title('Original Data on Source Grid')
plt.show()
</code></pre>
<h2 id="2-defining-the-target-grid">2. Defining the Target Grid</h2>
<p>You need to define the grid you want to regrid to. This can be another dataset's grid, or you can create a new one. Here, we create a regular lat/lon grid:</p>
<pre><code class="language-python">import numpy as np

target_grid = xr.Dataset({
    'lat': (['lat'], np.arange(-90, 90.1, 1.0)),
    'lon': (['lon'], np.arange(0, 360, 1.0)),
})
</code></pre>
<h3 id="visualizing-the-target-grid">Visualizing the Target Grid</h3>
<pre><code class="language-python">plt.figure()
plt.scatter(target_grid['lon'], target_grid['lat'], s=1)
plt.xlabel('Longitude')
plt.ylabel('Latitude')
plt.title('Target Grid Points')
plt.show()
</code></pre>
<h2 id="3-regridding-with-xesmf">3. Regridding with xESMF</h2>
<p>xESMF supports several regridding methods:</p>
<h3 id="choosing-a-regridding-algorithm">Choosing a Regridding Algorithm</h3>
<p>The choice of algorithm depends on your data and scientific goals:</p>
<ul>
<li>
<p><strong>Bilinear</strong>: Uses weighted averages of the four nearest grid points. It is smooth and works well for continuous variables (e.g., temperature, pressure). However, it does not conserve the total sum of the variable, so it is not suitable for fluxes or quantities where conservation is important.</p>
</li>
<li>
<p><strong>Conservative</strong>: Ensures that the integral (sum) of the variable is preserved during regridding. This is essential for variables like precipitation, runoff, or any fluxes. It requires both source and target grids to define cell boundaries (i.e., grid must be defined by cell centers and edges). It can be sensitive to missing values (NaNs), which may cause the output to be NaN if any input cell is NaN.</p>
</li>
<li>
<p><strong>Conservative-normed</strong>: Similar to conservative, but normalizes the weights so that if some source cells are NaN, the valid part of the cell is still used. This is especially useful for satellite data or observational products with missing values, as it avoids propagating NaNs unnecessarily. Use this when you want conservation but need to handle missing data robustly.</p>
</li>
<li>
<p><strong>Nearest_s2d / nearest_d2s</strong>: Assigns the value of the nearest source (or destination) grid cell. This is fast and preserves original values, but can introduce blocky artifacts. Use for categorical data (e.g., land/sea masks, land cover types) or when you want to avoid interpolation.</p>
</li>
<li>
<p><strong>Patch</strong>: A higher-order method that can provide smoother results for some variables, but is less commonly used and more computationally intensive.</p>
</li>
</ul>
<h4 id="summary-table">Summary Table</h4>
<table>
<thead>
<tr>
<th>Algorithm</th>
<th>Preserves Integrals</th>
<th>Handles NaNs Well</th>
<th>Smooth</th>
<th>Use For</th>
</tr>
</thead>
<tbody>
<tr>
<td>bilinear</td>
<td>No</td>
<td>Moderate</td>
<td>Yes</td>
<td>Continuous fields</td>
</tr>
<tr>
<td>conservative</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>Fluxes, precipitation</td>
</tr>
<tr>
<td>conservative-normed</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>Fluxes with missing data</td>
</tr>
<tr>
<td>nearest_s2d/d2s</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>Categorical, masks</td>
</tr>
<tr>
<td>patch</td>
<td>No</td>
<td>Moderate</td>
<td>Yes</td>
<td>Advanced, smooth fields</td>
</tr>
</tbody>
</table>
<h3 id="example-bilinear-regridding">Example: Bilinear Regridding</h3>
<pre><code class="language-python">import xesmf as xe

regridder = xe.Regridder(ds, target_grid, 'bilinear')
regridded = regridder(ds['your_variable'])
regridded.to_netcdf('output_bilinear.nc')
</code></pre>
<h3 id="example-conservative-regridding">Example: Conservative Regridding</h3>
<pre><code class="language-python">regridder_cons = xe.Regridder(ds, target_grid, 'conservative')
regridded_cons = regridder_cons(ds['your_variable'])
regridded_cons.to_netcdf('output_conservative.nc')
</code></pre>
<h3 id="example-conservative-normed-regridding">Example: Conservative-normed Regridding</h3>
<p>The <strong>conservative-normed</strong> method is designed to handle missing values (NaNs) more robustly than standard conservative regridding. In the standard conservative method, if any part of a source cell is NaN, the entire destination cell may become NaN. The conservative-normed method normalizes the weights so that only the valid (non-NaN) fraction of the source cell contributes to the destination cell, preventing unnecessary propagation of NaNs.</p>
<h4 id="using-a-mask-layer">Using a 'mask' Layer</h4>
<p>To take full advantage of conservative-normed, you should provide a <code>mask</code> variable in your xarray dataset. This mask should be a DataArray with the same shape as your data, where valid data points are marked as 1 (or True) and missing/invalid points as 0 (or False). xESMF will use this mask to determine which parts of the grid are valid during regridding.</p>
<p>Example of adding a mask:</p>
<pre><code class="language-python">import numpy as np

# Suppose ds['your_variable'] contains NaNs for missing data
mask = (~np.isnan(ds['your_variable'])).astype(int)
ds['mask'] = (ds['your_variable'].dims, mask)

# Now use conservative-normed
regridder_normed = xe.Regridder(ds, target_grid, 'conservative_normed')
regridded_normed = regridder_normed(ds['your_variable'])
regridded_normed.to_netcdf('output_conservative_normed.nc')
</code></pre>
<p>If you do not provide a mask, xESMF will infer it from the NaN pattern in your data, but explicitly providing a mask is more robust and recommended for complex or irregular missing data patterns.</p>
<p>For more, see the <a href="https://xesmf.readthedocs.io/en/latest/notebooks/Masking.html">xESMF documentation on masking</a>.</p>
<h3 id="example-nearest-neighbor-regridding">Example: Nearest Neighbor Regridding</h3>
<pre><code class="language-python">regridder_nn = xe.Regridder(ds, target_grid, 'nearest_s2d')
regridded_nn = regridder_nn(ds['your_variable'])
regridded_nn.to_netcdf('output_nearest.nc')
</code></pre>
<h2 id="4-considerations">4. Considerations</h2>
<h3 id="working-with-large-datasets">Working with Large Datasets</h3>
<p>Regridding large datasets (e.g., high-resolution satellite data or long time series) can be memory- and compute-intensive. Here are some tips to improve performance:</p>
<ul>
<li>
<p><strong>Use Dask for Chunking</strong>: xarray and xESMF support dask arrays, which allow you to process data in chunks and parallelize operations. Open your dataset with chunking:</p>
<p>```python
ds = xr.open_dataset('input_data.nc', chunks={'time': 10, 'lat': 100, 'lon': 100})</p>
<h1 id="adjust-chunk-sizes-to-fit-your-memory-and-data-shape">Adjust chunk sizes to fit your memory and data shape</h1>
<p>```</p>
</li>
<li>
<p><strong>Saving and Reusing Regridding Weights</strong>: When you create a regridder in xESMF, it computes a weight matrix that maps the source grid to the target grid. This computation can be slow for large grids, but you can save the weights to a file and reload them later for faster repeated regridding.</p>
<p>Example:</p>
<p>```python</p>
<h1 id="first-time-compute-and-save-weights">First time: compute and save weights</h1>
<p>regridder = xe.Regridder(ds, target_grid, 'bilinear', filename='my_weights.nc')</p>
<h1 id="next-time-reuse-the-saved-weights-much-faster">Next time: reuse the saved weights (much faster)</h1>
<p>regridder = xe.Regridder(ds, target_grid, 'bilinear', filename='my_weights.nc', reuse_weights=True)
```</p>
<p>This is especially useful when you need to regrid many variables or process data in chunks, as you only need to compute the weights once.</p>
</li>
<li>
<p><strong>Parallel Processing</strong>: If you have access to a cluster or multicore machine, dask can distribute the computation. Set up a dask cluster for even faster processing.</p>
</li>
<li>
<p><strong>Reduce Data Size</strong>: If possible, subset your data in time or space before regridding, or use coarser grids for exploratory analysis.</p>
</li>
<li>
<p><strong>Monitor Memory Usage</strong>: Large regridding operations can use a lot of RAM. Monitor your system and adjust chunk sizes or process data in smaller batches if needed.</p>
</li>
</ul>
<p>For more details, see the <a href="https://xesmf.readthedocs.io/en/latest/parallel.html">xESMF documentation on dask and performance</a>.</p>
<h2 id="5-visualizing-the-results">5. Visualizing the Results</h2>
<pre><code class="language-python">import matplotlib.pyplot as plt

regridded.plot()
plt.title('Regridded Data (Bilinear)')
plt.show()
</code></pre>
<h3 id="comparing-input-and-output">Comparing Input and Output</h3>
<p>You can compare the original and regridded data side by side:</p>
<pre><code class="language-python">fig, axs = plt.subplots(1, 2, figsize=(12, 5))
ds['your_variable'].plot(ax=axs[0])
axs[0].set_title('Original Data')
regridded.plot(ax=axs[1])
axs[1].set_title('Regridded Data (Bilinear)')
plt.tight_layout()
plt.show()
</code></pre>
<p>For more advanced analysis, you can plot the difference:</p>
<pre><code class="language-python">diff = regridded - ds['your_variable'].interp_like(regridded)
diff.plot()
plt.title('Difference After Regridding')
plt.show()
</code></pre>
<h2 id="6-references">6. References</h2>
<ul>
<li><a href="https://xesmf.readthedocs.io/">xESMF Documentation</a></li>
<li><a href="https://docs.xarray.dev/">xarray Documentation</a></li>
</ul>
<hr />
<p>This tutorial should help you get started with regridding 2D NetCDF datasets in Python using xESMF. Adjust the code to your specific data and needs!</p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../linux_cheat_sheet/" class="btn btn-neutral float-left" title="Linux Cheat Sheet"><span class="icon icon-circle-arrow-left"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/leeds-bag/bag_wiki" class="fa fa-code-fork" style="color: #fcfcfc"> leeds-bag/bag_wiki</a>
        </span>
    
    
      <span><a href="../linux_cheat_sheet/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
